package oogasalad.player.model.strategies.collision;

import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.List;
import oogasalad.engine.config.EntityPlacement;
import oogasalad.engine.records.CollisionContextRecord;
import oogasalad.engine.records.CollisionContextRecord.StrategyAppliesTo;
import oogasalad.engine.records.config.model.SettingsRecord;
import oogasalad.player.model.Entity;
import oogasalad.player.model.GameMapInterface;
import oogasalad.player.model.GameState;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class TeleportToPartnerPortalStrategyTest {

  // Test generated by Claude 3.5 Sonnet with new IntelliJ code assist
  private TeleportToPartnerPortalStrategy strategy;
  private GameMapInterface mockGameMap;
  private Entity mockEntityToTeleport;
  private Entity mockPortalEntity;
  private Entity mockPartnerPortal;
  private GameState mockGameState;
  private static final String PORTAL_TYPE = "bluePortal";
  private static final String PARTNER_TYPE = "orangePortal";
  private static final double OFFSET_X = 1.0;
  private static final double OFFSET_Y = 1.0;

  @BeforeEach
  void setUp() {
    strategy = new TeleportToPartnerPortalStrategy(PORTAL_TYPE, PARTNER_TYPE, false, OFFSET_X,
        OFFSET_Y);
    mockGameMap = mock(GameMapInterface.class);
    mockEntityToTeleport = mock(Entity.class);
    mockPortalEntity = mock(Entity.class);
    mockPartnerPortal = mock(Entity.class);
    mockGameState = new GameState(mock(SettingsRecord.class));

    // Setup basic entity placements with type strings
    EntityPlacement mockPortalPlacement = mock(EntityPlacement.class);
    EntityPlacement mockPartnerPlacement = mock(EntityPlacement.class);
    EntityPlacement mockEntityPlacement = mock(EntityPlacement.class);

    when(mockPortalEntity.getEntityPlacement()).thenReturn(mockPortalPlacement);
    when(mockPartnerPortal.getEntityPlacement()).thenReturn(mockPartnerPlacement);
    when(mockEntityToTeleport.getEntityPlacement()).thenReturn(mockEntityPlacement);

    // Set up default type strings
    when(mockPortalPlacement.getTypeString()).thenReturn(PORTAL_TYPE);
    when(mockPartnerPlacement.getTypeString()).thenReturn(PARTNER_TYPE);
  }

  @Test
  void handleCollision_WithValidPortalAndPartner_TeleportsEntity() {
    // Set up partner portal position
    when(mockPartnerPortal.getEntityPlacement().getX()).thenReturn(5.0);
    when(mockPartnerPortal.getEntityPlacement().getY()).thenReturn(5.0);

    // Set up game map to return partner portal
    List<Entity> entities = new ArrayList<>();
    entities.add(mockPartnerPortal);
    when(mockGameMap.iterator()).thenReturn(entities.iterator());

    CollisionContextRecord context = new CollisionContextRecord(
        mockEntityToTeleport,
        mockPortalEntity,
        mockGameMap,
        mockGameState,
        StrategyAppliesTo.ENTITY1
    );

    strategy.handleCollision(context);

    // Verify entity was teleported to correct location
    verify(mockEntityToTeleport.getEntityPlacement()).setX(6.0); // 5.0 + OFFSET_X
    verify(mockEntityToTeleport.getEntityPlacement()).setY(6.0); // 5.0 + OFFSET_Y
  }

  @Test
  void handleCollision_WithWrongPortalType_DoesNotTeleport() {
    when(mockPortalEntity.getEntityPlacement().getTypeString()).thenReturn("wrongPortal");

    CollisionContextRecord context = new CollisionContextRecord(
        mockEntityToTeleport,
        mockPortalEntity,
        mockGameMap,
        mockGameState,
        StrategyAppliesTo.ENTITY1
    );

    strategy.handleCollision(context);

    // Verify entity position was not changed
    verify(mockEntityToTeleport.getEntityPlacement(), never()).setX(anyDouble());
    verify(mockEntityToTeleport.getEntityPlacement(), never()).setY(anyDouble());
  }

  @Test
  void handleCollision_WithNoPartnerPortals_DoesNotTeleport() {
    when(mockGameMap.iterator()).thenReturn(new ArrayList<Entity>().iterator());

    CollisionContextRecord context = new CollisionContextRecord(
        mockEntityToTeleport,
        mockPortalEntity,
        mockGameMap,
        mockGameState,
        StrategyAppliesTo.ENTITY1
    );

    strategy.handleCollision(context);

    // Verify entity position was not changed
    verify(mockEntityToTeleport.getEntityPlacement(), never()).setX(anyDouble());
    verify(mockEntityToTeleport.getEntityPlacement(), never()).setY(anyDouble());
  }

  @Test
  void handleCollision_WithRandomPartnerEnabled_SelectsRandomPortal() {
    // Create strategy with random partner selection
    strategy = new TeleportToPartnerPortalStrategy(PORTAL_TYPE, PARTNER_TYPE, true);

    // Set up multiple partner portals
    Entity mockPartnerPortal2 = mock(Entity.class);
    EntityPlacement mockPartnerPlacement2 = mock(EntityPlacement.class);
    when(mockPartnerPortal2.getEntityPlacement()).thenReturn(mockPartnerPlacement2);
    when(mockPartnerPlacement2.getTypeString()).thenReturn(PARTNER_TYPE);

    List<Entity> entities = new ArrayList<>();
    entities.add(mockPartnerPortal);
    entities.add(mockPartnerPortal2);
    when(mockGameMap.iterator()).thenReturn(entities.iterator());

    // Run multiple times to ensure random selection
    for (int i = 0; i < 10; i++) {
      CollisionContextRecord context = new CollisionContextRecord(
          mockEntityToTeleport,
          mockPortalEntity,
          mockGameMap,
          mockGameState,
          StrategyAppliesTo.ENTITY1
      );

      strategy.handleCollision(context);
    }

    // Verify that teleportation occurred (exact destination varies due to randomness)
    verify(mockEntityToTeleport.getEntityPlacement(), atLeast(1)).setX(anyDouble());
    verify(mockEntityToTeleport.getEntityPlacement(), atLeast(1)).setY(anyDouble());
  }

  @Test
  void handleCollision_WithStrategyAppliesToEntity2_TeleportsCorrectEntity() {
    when(mockPartnerPortal.getEntityPlacement().getX()).thenReturn(5.0);
    when(mockPartnerPortal.getEntityPlacement().getY()).thenReturn(5.0);

    List<Entity> entities = new ArrayList<>();
    entities.add(mockPartnerPortal);
    when(mockGameMap.iterator()).thenReturn(entities.iterator());

    CollisionContextRecord context = new CollisionContextRecord(
        mockPortalEntity,
        mockEntityToTeleport,
        mockGameMap,
        mockGameState,
        StrategyAppliesTo.ENTITY2
    );

    strategy.handleCollision(context);

    // Verify the correct entity was teleported
    verify(mockEntityToTeleport.getEntityPlacement()).setX(6.0);
    verify(mockEntityToTeleport.getEntityPlacement()).setY(6.0);
  }
}
